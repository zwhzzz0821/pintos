# p1设计思路

## exercise 1
### exercise 1.1

这个exercise的内容是避免`timer_sleep`的忙等，观察代码，我们可以先看到现在timer的实现是循环调用`thread_yield`来占用cpu，忙等至ticks到达，然而这样的效率很低，通过观察线程的状态，我们增加定义线程睡眠状态了：
```
enum thread_status
{
  THREAD_RUNNING, /**< Running thread. */
  THREAD_READY,   /**< Not running but ready to run. */
  THREAD_BLOCKED, /**< Waiting for an event to trigger. */
  THREAD_DYING    /**< About to be destroyed. */
  THREAD_SLEEPING /**< Sleeping until a specified time. */
};
```
我们将线程睡眠时，将其转换成`THREAD_SLEEPING`状态，并通过将其状态维护在一个`sleep_list`，来实现快速的唤醒睡眠线程，`sleep_list`需要在插入的时候按照`wakeup_time`进行排序。那按我的实现，`timer_sleep`不需要开中断了，而是需要关中断来保证转换到`THREAD_SLEEPING`状态的时候不发生一些奇怪的问题。
这个实现可以通过除了`alarm-priority`以外的`alram`测试

## exercise 2
### exericise 2.1

要实现优先级调度，首先先需要按优先级的高低来维护`ready_list`，这块就是把之前`push_back`都改成按优先级来进行`insert`即可